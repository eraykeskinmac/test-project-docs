---
title: Advanced Patterns
description: Learn advanced design patterns and techniques
---

# Advanced Patterns

Master advanced concepts and patterns for building robust applications.

## Higher-Order Components

Create reusable component logic:

```tsx title="withAuth.tsx"
import { ComponentType } from 'react';

export function withAuth<P extends object>(
  Component: ComponentType<P>
) {
  return function AuthComponent(props: P) {
    const { user } = useAuth();
    
    if (!user) {
      return <LoginPrompt />;
    }
    
    return <Component {...props} />;
  };
}

// Usage
const ProtectedPage = withAuth(Dashboard);
```

## Custom Hooks

Build reusable hook patterns:

```tsx title="useLocalStorage.ts"
import { useState, useEffect } from 'react';

export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(storedValue));
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
  }, [key, storedValue]);

  return [storedValue, setStoredValue];
}
```

## Render Props Pattern

Share code between components using render props:

```tsx title="DataFetcher.tsx"
interface DataFetcherProps<T> {
  url: string;
  render: (data: T | null, loading: boolean, error: Error | null) => JSX.Element;
}

export function DataFetcher<T>({ url, render }: DataFetcherProps<T>) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [url]);

  return render(data, loading, error);
}

// Usage
<DataFetcher
  url="/api/users"
  render={(data, loading, error) => {
    if (loading) return <Spinner />;
    if (error) return <Error message={error.message} />;
    return <UserList users={data} />;
  }}
/>
```

## Compound Components

Create flexible component APIs:

```tsx title="Tabs.tsx"
interface TabsContextValue {
  activeTab: string;
  setActiveTab: (tab: string) => void;
}

const TabsContext = createContext<TabsContextValue | null>(null);

export function Tabs({ children, defaultTab }: TabsProps) {
  const [activeTab, setActiveTab] = useState(defaultTab);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      {children}
    </TabsContext.Provider>
  );
}

export function TabList({ children }: TabListProps) {
  return <div className="tab-list">{children}</div>;
}

export function Tab({ id, children }: TabProps) {
  const context = useContext(TabsContext);
  return (
    <button
      className={context?.activeTab === id ? 'active' : ''}
      onClick={() => context?.setActiveTab(id)}
    >
      {children}
    </button>
  );
}

export function TabPanel({ id, children }: TabPanelProps) {
  const context = useContext(TabsContext);
  return context?.activeTab === id ? <>{children}</> : null;
}

// Usage
<Tabs defaultTab="overview">
  <TabList>
    <Tab id="overview">Overview</Tab>
    <Tab id="details">Details</Tab>
  </TabList>
  <TabPanel id="overview">Overview content</TabPanel>
  <TabPanel id="details">Details content</TabPanel>
</Tabs>
```

## Performance Optimization

### Memoization

```tsx
import { memo, useMemo, useCallback } from 'react';

const ExpensiveComponent = memo(({ data }: Props) => {
  const processedData = useMemo(
    () => heavyComputation(data),
    [data]
  );

  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []);

  return <div onClick={handleClick}>{processedData}</div>;
});
```

### Code Splitting

```tsx
import { lazy, Suspense } from 'react';

const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <HeavyComponent />
    </Suspense>
  );
}
```

## Best Practices

<Callout type="warning">
Always measure performance before optimizing. Premature optimization can lead to complex code without real benefits.
</Callout>

### Key Principles

1. **Keep it Simple**: Start with simple patterns and add complexity only when needed
2. **Type Safety**: Use TypeScript generics for reusable components
3. **Composition**: Prefer composition over inheritance
4. **Separation of Concerns**: Keep logic separate from presentation
